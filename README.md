<div dir="rtl">

![img_5.png](img_5.png)
## 🌐 Network Communication Project – TCP/IP, Wireshark & Socket Programming

---

## 📖 סקירה כללית
פרויקט זה בוצע במסגרת קורס **רשתות תקשורת** ומטרתו להעמיק את ההבנה המעשית והעיונית בעקרונות התקשורת ברשת, מודל TCP/IP, אריזת נתונים, ולכידת וניתוח תעבורה באמצעות Wireshark.

הפרויקט משלב בין:
- 📘 ידע תיאורטי (מודל שכבות TCP/IP)
- 🧪 ניסויים וניתוח תעבורה אמיתית
- 💻 מימוש מערכת Client–Server מלאה

הפרויקט מחולק לשני חלקים מרכזיים:
1. 🦈 אריזת נתונים ולכידת מנות באמצעות Wireshark  
2. 💬 מימוש יישום רשת מבוסס TCP וניתוח תעבורתו  

---

## 🧩 חלק 1 – אריזת נתונים ולכידת מנות (Wireshark)

### 🎯 מטרות החלק
- הבנת תהליך אריזת הנתונים משכבת היישום ועד שכבת הרשת  
- תרגול עבודה עם Wireshark ולכידת מנות  
- קישור בין מידע לוגי (CSV) לתעבורת רשת בפועל  

---

## 📁 שלב 1 – יצירת קובץ CSV (שכבת היישום)
נוצר קובץ CSV בעזרת הAI (chatgpt) המכיל הודעות ברמת שכבת היישום.

**שדות הקובץ:**
- msg_id  
- app_protocol  
- src_app  
- dst_app  
- message  
- timestamp 
- src_port
- dst_port

**דוגמה:**
    1,HTTP,client_browser,web_server,GET /index.html,0.015,42069,80

📘 **מה למדנו:**  
כיצד הודעות נראות ברמת היישום לפני שהן נארזות לשכבות התקשורת, והחשיבות של הפרדת תוכן ממנגנון התקשורת.

---

## 📓 שלב 2 – עיבוד הקובץ במחברת Jupyter
בוצעה טעינה של קובץ ה-CSV והדמיה של תהליך אריזת הנתונים בשכבות:
- Application  
- Transport (TCP)  
- Network (IP)  

## תיאור והסבר על תהליך אריזת המנות :

בחלק זה דימינו את תהליך ה-**Encapsulation** (אריזה בשכבות) המתרחש במודל TCP/IP, תוך שימוש במחברת Jupyter ובקובץ נתוני קלט. התהליך התבצע בצורה היררכית, מהשכבה העליונה לתחתונה:

1. **שכבת האפליקציה (Application Layer):**
   * המקור לנתונים הוא קובץ ה-CSV (`group11_http_input.csv`) המכיל הודעות HTTP גולמיות.
   * כל שורה בקובץ מייצגת הודעת אפליקציה, למשל: `GET /logo.png` או תשובת שרת `HTTP/1.1 301 Moved`.
   * במחברת, המידע האפליקטיבי נטען ל-DataFrame ועבר המרה לבייטים (Encoding) כדי שיוכל לשמש כ-"Payload" לשכבות הבאות.

2. **שכבת התעבורה (Transport Layer - TCP):**
   * עבור כל הודעה, נבנתה כותרת TCP (Header) בעזרת פונקציות המרה במחברת.
   * הכותרת כללה את פורט המקור ופורט היעד שהוגדרו ידנית ב-CSV (לדוגמה: פורט `42069` עבור הלקוח ופורט `12345` עבור השרת).
   * בשלב זה נקבעו דגלי הבקרה (Flags) כגון `PSH+ACK` (ערך `0x18`) כדי לסמן שהמידע מוכן להעברה מיידית לאפליקציה בצד השני.

3. **שכבת הרשת (Internet Layer - IPv4):**
   * חבילת ה-TCP נארזה בתוך כותרת IP בעזרת פונקציית בנייה ייעודית במחברת.
   * הוגדרו כתובות ה-IP של המקור והיעד (בפרויקט זה השתמשנו בכתובת הלופבק `127.0.0.1`).
   * התהליך כלל חישוב Checksum עבור ה-IP וה-TCP כדי להבטיח את תקינות הנתונים במעבר.

4. **שכבת הקישור והעברה (Link Layer & Sending):**
   * המנה המוכנה (IP + TCP + Data) הועברה למערכת השליחה.
   * במערכת Windows, השתמשנו בספריית **Scapy** ובמנהל ההתקן **Npcap** כדי "להזריק" את המנה ישירות לשכבת הקישור, מה שאפשר למנה לעבור בכרטיס הרשת הווירטואלי (Loopback Adapter) למרות מגבלות מערכת ההפעלה על Raw Sockets.

---

## 🦈 שלב 3 – לכידת תעבורה ב-Wireshark
בוצעה לכידת תעבורה חיה תוך שימוש במסנני TCP ושמירת הקובץ בפורמט pcap.

## תיאור והסבר על תהליך הלכידה והניתוח ב-Wireshark :

לאחר שלב אריזת המנות, ביצענו לכידה של התעבורה בזמן אמת כדי לוודא שהמנות עברו את כל שלבי המודל בצורה תקינה. התהליך כלל את הצעדים הבאים:

1. **הגדרת ממשק הלכידה:**
   * במערכת Windows, הקוד במחברת זיהה והשתמש במתאם הלופבק הייעודי (**Npcap Loopback Adapter**).
   * פעולה זו הכרחית מכיוון שתעבורה פנימית (127.0.0.1) אינה עוברת דרך כרטיס הרשת הפיזי, ולכן נדרש "כרטיס רשת וירטואלי" המאפשר ל-Wireshark להאזין לתקשורת המקומית.

2. **תהליך השליחה והזרקת המנות:**
   * במחברת הופעל תהליך שרץ בלולאה על פני כל השורות ב-CSV. 
   * עבור כל הודעה, הקוד חילץ את תוכן ההודעה והשתמש בפונקציה `transport.send` כדי להעביר אותה.
   * הקוד השתמש בספריית **Scapy** כדי לבנות אובייקטים מסוג `IP` ו-`TCP`. הזרקת המנות בוצעה ישירות לשכבת הקישור (Layer 2) תוך עקיפת מחסומי אבטחה של מערכת ההפעלה.
   * הקוד הוסיף השהייה מתוזמנת (`time.sleep`) בין שליחה לשליחה כדי לאפשר תצוגה כרונולוגית ברורה ב-Wireshark ולמנוע עומס על ה-Buffer.



3. **סינון וניתוח ב-Wireshark:**
   * כדי לבודד את התעבורה הרלוונטית בקובץ הלכידה, השתמשנו במסננים (Filters) כגון: `ip.addr == 127.0.0.1`.
   * בבחינת המנות בתוך קובץ ה-PCAP, זיהינו את חבילות ה-**IPv4** שהכילו בתוכן את סגמנט ה-**TCP**.
   * וידאנו שה-Payload (המטען) של המנות מכיל את מחרוזות הטקסט מה-CSV המקורי (כמו הודעות ה-HTTP השונות).

4. **אימות מבנה המנה מהלכידה הממשית:**
   * ניתחנו את השדות הטכניים כפי שהם מופיעים ב-Wireshark:
     * **Source/Destination Port:** זיהינו את הפורטים כפי שהוגדרו ( פורט `12345` ו-`42069`).
     * **Sequence Numbers:** ניתן לראות כיצד כל מנה מקבלת מספר סידורי המאפשר את הרכבת המידע בצד המקבל.
     * **Flags:** זיהינו שימוש בדגלי **PSH (Push)** ו-**ACK** (ערך הקסדצימלי `0x18`), המורים למערכת ההפעלה להעביר את הנתונים מיד לאפליקציה מבלי להמתין למילוי מלא של המאגר (Buffer).

## תיאור והסבר של תעבורה שנלקדה ב-Wireshark :


### 1. מבנה השכבות (The OSI Model in Practice)
בכל מנה שנבחר ב-Wireshark, ניתן לראות את ההיררכיה שיצרנו במחברת. השכבות מסודרות מהנמוכה לגבוהה: Ethernet (קישור), IPv4 (רשת), TCP (תעבורה), ונתוני ה-HTTP (אפליקציה).

![img.png](img.png)

### 2. שכבת ה-IP וכתובות הלופבק
בלכידה ניתן לראות שכתובות המקור (Source) והיעד (Destination) הן `127.0.0.1`. זהו אימות לכך שהזרקת המנות עבדה דרך ה-Npcap Loopback Adapter. ניתן לראות בשדה ה-Protocol שכתוב `TCP`, מה שמראה שה-IP "נושא" בתוכו סגמנט תעבורה.

![img_1.png](img_1.png)

### 3. פורטים בשכבת התעבורה (TCP Ports)
השתמשנו בפורטים שהגדרנו ידנית ב-CSV. ב-Wireshark ניתן לראות את ה-Source Port (למשל `42069` בבקשת לקוח) ואת ה-Destination Port (למשל `80` עבור שרת ה-Web). הפרדה זו מאפשרת למחשב לדעת לאזו אפליקציה לשלוח את המידע.

![img_2.png](img_2.png)

### 4. דגלי בקרה (Flags)
שדה ה-Flags ב-TCP מספק הנחיות לניהול הקשר. במחברת הגדרנו את הערך הקסדצימלי `0x18`.
* **מה זה אומר?** ערך זה מייצג שילוב של **PSH (Push)** ו-**ACK (Acknowledgment)**.
* **איך רואים זאת בלכידה?** תחת עץ ה-Flags ב-TCP, נראה ששני הדגלים הללו הם היחידים שמסומנים ב-"Set" (1). דגל ה-PSH מבטיח שהנתונים יעברו מיד לאפליקציה ולא יתעכבו בזיכרון המערכת.

![img_3.png](img_3.png)

### 5. תוכן המנה (Payload / Data)
זהו החלק ה"עטוף" ביותר. בתוך ה-Payload של ה-TCP, ניתן לראות את המחרוזת המקורית שכתבנו ב-CSV.
* **דוגמה מהלכידה:** אם נסתכל על הייצוג ב-ASCII (בצד ימין למטה ב-Wireshark), נראה בבירור טקסט כמו `GET /logo.png` או `HTTP/1.1 301 Moved`. זהו האישור הסופי לכך שכל תהליך האריזה הצליח והמידע הגיע ליעדו ללא שינוי.

![img_4.png](img_4.png)
---

## 💬 חלק 2 – מימוש יישום רשת וניתוח תעבורה

### 🎯 מטרות החלק
- מימוש מערכת Client–Server מבוססת TCP  
- עבודה עם Sockets ברמה נמוכה  
- טיפול בריבוי לקוחות  
- ניתוח תעבורת רשת של יישום אמיתי  

---

## 🏗️ ארכיטקטורת המערכת

### 🖥️ Server
- שרת TCP מאזין לחיבורים נכנסים  
- תומך בלפחות 5 לקוחות בו-זמנית  
- שימוש ב-Multithreading  
- תיווך בין לקוחות  
- טיפול בניתוקים לא צפויים  

### 💻 Client
- התחברות לשרת  
- שליחה וקבלה של הודעות בזמן אמת  
- ממשק גרפי (GUI) – ⭐ בונוס  
- פרוטוקול הודעות מבוסס JSON  

📘 **מה למדנו:**  
ניהול חיבורים מרובים, עבודה עם sockets, והפרדת אחריות בין רכיבי מערכת מבוזרת.

---

## 📡 פרוטוקול התקשורת
התקשורת בין השרת ללקוחות מבוססת הודעות JSON קריאות וניתנות להרחבה.

דוגמה:
    {
      "type": "message",
      "sender": "Alice",
      "receiver": "Bob",
      "content": "Hello!"
    }

📘 **מה למדנו:**  
חשיבות של פרוטוקול ברור, קריא וניתן להרחבה במערכות רשת.

---

## ▶️ הוראות התקנה והרצה

### ⚙️ דרישות מוקדמות
- Python 3.9 ומעלה  

### 📦 התקנת ספריות
    pip install kivy customtkinter

### 🚀 הרצת השרת
    python server.py

### 💬 הרצת לקוח
    python client_kivy.py

ניתן להריץ מספר לקוחות במקביל.

---

## 🔍 ניתוח תעבורה של היישום
בוצעה לכידת תעבורה של יישום הצ'אט בעזרת Wireshark:
- זוהה TCP Handshake (SYN, SYN-ACK, ACK)  
- נצפו חיבורי TCP פעילים  
- נותחה התעבורה עד שכבת הרשת (IP)  

📘 **מה למדנו:**  
כיצד קוד תוכנה מתבטא בתעבורת רשת אמיתית והקשר הישיר בין שכבת היישום לשכבות התקשורת.

---

## 🤖 שימוש בבינה מלאכותית (AI)
נעשה שימוש בבינה מלאכותית ככלי עזר ללמידה ולפיתוח.

**מטרות השימוש:**
- הבנת פרוטוקולי רשת  
- שיפור מבנה הקוד  
- ניסוח והבהרת הסברים תיאורטיים  

📘 **מה למדנו:**  
AI הוא כלי עזר חזק כאשר משתמשים בו בצורה ביקורתית ומושכלת.

---

## 🏁 סיכום
הפרויקט סיפק הבנה מעמיקה של:
- מודל TCP/IP  
- תקשורת מבוססת Sockets  
- ריבוי לקוחות וניהול חיבורים  
- לכידה וניתוח תעבורת רשת אמיתית  

השילוב בין תיאוריה, מימוש וניתוח תעבורה תרם להבנה עמוקה של מערכות תקשורת מבוזרות.

⭐ הפרויקט עומד בכל דרישות הקורס ואף כולל הרחבות (GUI, ריבוי תהליכים) המזכות בבונוס.

</div>
